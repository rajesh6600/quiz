// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: questions.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getQuestionPool = `-- name: GetQuestionPool :many
SELECT question_id, source, prompt, options, correct_answer, metadata, verified, created_at, updated_at
FROM questions
WHERE verified = true
ORDER BY RANDOM()
LIMIT $1
`

func (q *Queries) GetQuestionPool(ctx context.Context, limit int32) ([]Question, error) {
	rows, err := q.db.Query(ctx, getQuestionPool, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.QuestionID,
			&i.Source,
			&i.Prompt,
			&i.Options,
			&i.CorrectAnswer,
			&i.Metadata,
			&i.Verified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertQuestion = `-- name: InsertQuestion :one
INSERT INTO questions (
    source,
    prompt,
    options,
    correct_answer,
    metadata,
    verified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    COALESCE($5, '{}'::jsonb),
    $6
)
RETURNING question_id, source, prompt, options, correct_answer, metadata, verified, created_at, updated_at
`

type InsertQuestionParams struct {
	Source        string      `json:"source"`
	Prompt        string      `json:"prompt"`
	Options       []string    `json:"options"`
	CorrectAnswer string      `json:"correct_answer"`
	Metadata      interface{} `json:"metadata"`
	Verified      bool        `json:"verified"`
}

func (q *Queries) InsertQuestion(ctx context.Context, arg InsertQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, insertQuestion,
		arg.Source,
		arg.Prompt,
		arg.Options,
		arg.CorrectAnswer,
		arg.Metadata,
		arg.Verified,
	)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Source,
		&i.Prompt,
		&i.Options,
		&i.CorrectAnswer,
		&i.Metadata,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertQuestionVerification = `-- name: UpsertQuestionVerification :one
UPDATE questions
SET verified = $1,
    metadata = COALESCE($2, metadata),
    updated_at = NOW()
WHERE question_id = $3
RETURNING question_id, source, prompt, options, correct_answer, metadata, verified, created_at, updated_at
`

type UpsertQuestionVerificationParams struct {
	Verified   bool        `json:"verified"`
	Metadata   []byte      `json:"metadata"`
	QuestionID pgtype.UUID `json:"question_id"`
}

func (q *Queries) UpsertQuestionVerification(ctx context.Context, arg UpsertQuestionVerificationParams) (Question, error) {
	row := q.db.QueryRow(ctx, upsertQuestionVerification, arg.Verified, arg.Metadata, arg.QuestionID)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Source,
		&i.Prompt,
		&i.Options,
		&i.CorrectAnswer,
		&i.Metadata,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

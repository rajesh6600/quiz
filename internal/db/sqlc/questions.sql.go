// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: questions.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getQuestionPool = `-- name: GetQuestionPool :many
SELECT question_id, source, category, difficulty, type, prompt, options, correct_answer, metadata, verified, created_at, updated_at
FROM questions
WHERE difficulty = ANY($2::text[])
  AND category = ANY($3::text[])
  AND verified = true
ORDER BY RANDOM()
LIMIT $1
`

type GetQuestionPoolParams struct {
	Limit        int32    `json:"limit"`
	Difficulties []string `json:"difficulties"`
	Categories   []string `json:"categories"`
}

func (q *Queries) GetQuestionPool(ctx context.Context, arg GetQuestionPoolParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, getQuestionPool, arg.Limit, arg.Difficulties, arg.Categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.QuestionID,
			&i.Source,
			&i.Category,
			&i.Difficulty,
			&i.Type,
			&i.Prompt,
			&i.Options,
			&i.CorrectAnswer,
			&i.Metadata,
			&i.Verified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertQuestion = `-- name: InsertQuestion :one
INSERT INTO questions (
    source,
    category,
    difficulty,
    type,
    prompt,
    options,
    correct_answer,
    metadata,
    verified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    COALESCE($8, '{}'::jsonb),
    $9
)
RETURNING question_id, source, category, difficulty, type, prompt, options, correct_answer, metadata, verified, created_at, updated_at
`

type InsertQuestionParams struct {
	Source        string      `json:"source"`
	Category      string      `json:"category"`
	Difficulty    string      `json:"difficulty"`
	Type          string      `json:"type"`
	Prompt        string      `json:"prompt"`
	Options       []string    `json:"options"`
	CorrectAnswer string      `json:"correct_answer"`
	Metadata      interface{} `json:"metadata"`
	Verified      bool        `json:"verified"`
}

func (q *Queries) InsertQuestion(ctx context.Context, arg InsertQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, insertQuestion,
		arg.Source,
		arg.Category,
		arg.Difficulty,
		arg.Type,
		arg.Prompt,
		arg.Options,
		arg.CorrectAnswer,
		arg.Metadata,
		arg.Verified,
	)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Source,
		&i.Category,
		&i.Difficulty,
		&i.Type,
		&i.Prompt,
		&i.Options,
		&i.CorrectAnswer,
		&i.Metadata,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertQuestionVerification = `-- name: UpsertQuestionVerification :one
UPDATE questions
SET verified = $1,
    metadata = COALESCE($2, metadata),
    updated_at = NOW()
WHERE question_id = $3
RETURNING question_id, source, category, difficulty, type, prompt, options, correct_answer, metadata, verified, created_at, updated_at
`

type UpsertQuestionVerificationParams struct {
	Verified   bool        `json:"verified"`
	Metadata   []byte      `json:"metadata"`
	QuestionID pgtype.UUID `json:"question_id"`
}

func (q *Queries) UpsertQuestionVerification(ctx context.Context, arg UpsertQuestionVerificationParams) (Question, error) {
	row := q.db.QueryRow(ctx, upsertQuestionVerification, arg.Verified, arg.Metadata, arg.QuestionID)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Source,
		&i.Category,
		&i.Difficulty,
		&i.Type,
		&i.Prompt,
		&i.Options,
		&i.CorrectAnswer,
		&i.Metadata,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

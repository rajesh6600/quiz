// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
    mode,
    question_count,
    per_question_seconds,
    global_timeout_seconds,
    seed_hash,
    leaderboard_eligible,
    status,
    created_by,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    COALESCE($9, '{}'::jsonb)
)
RETURNING match_id, mode, question_count, per_question_seconds, global_timeout_seconds, seed_hash, leaderboard_eligible, started_at, completed_at, status, created_by, created_at, updated_at, metadata
`

type CreateMatchParams struct {
	Mode                 string      `json:"mode"`
	QuestionCount        int16       `json:"question_count"`
	PerQuestionSeconds   int16       `json:"per_question_seconds"`
	GlobalTimeoutSeconds int16       `json:"global_timeout_seconds"`
	SeedHash             string      `json:"seed_hash"`
	LeaderboardEligible  bool        `json:"leaderboard_eligible"`
	Status               string      `json:"status"`
	CreatedBy            pgtype.UUID `json:"created_by"`
	Metadata             interface{} `json:"metadata"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.Mode,
		arg.QuestionCount,
		arg.PerQuestionSeconds,
		arg.GlobalTimeoutSeconds,
		arg.SeedHash,
		arg.LeaderboardEligible,
		arg.Status,
		arg.CreatedBy,
		arg.Metadata,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.Mode,
		&i.QuestionCount,
		&i.PerQuestionSeconds,
		&i.GlobalTimeoutSeconds,
		&i.SeedHash,
		&i.LeaderboardEligible,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const createPlayerMatchState = `-- name: CreatePlayerMatchState :exec
INSERT INTO player_match_state (
    match_id,
    user_id,
    is_guest,
    status,
    answers
) VALUES (
    $1,
    $2,
    $3,
    $4,
    COALESCE($5, '[]'::jsonb)
)
ON CONFLICT (match_id, user_id) DO NOTHING
`

type CreatePlayerMatchStateParams struct {
	MatchID pgtype.UUID `json:"match_id"`
	UserID  pgtype.UUID `json:"user_id"`
	IsGuest bool        `json:"is_guest"`
	Status  string      `json:"status"`
	Answers interface{} `json:"answers"`
}

func (q *Queries) CreatePlayerMatchState(ctx context.Context, arg CreatePlayerMatchStateParams) error {
	_, err := q.db.Exec(ctx, createPlayerMatchState,
		arg.MatchID,
		arg.UserID,
		arg.IsGuest,
		arg.Status,
		arg.Answers,
	)
	return err
}

const getMatchForSummary = `-- name: GetMatchForSummary :one
SELECT match_id, mode, question_count, per_question_seconds, global_timeout_seconds, seed_hash, leaderboard_eligible, started_at, completed_at, status, created_by, created_at, updated_at, metadata
FROM matches
WHERE match_id = $1
`

func (q *Queries) GetMatchForSummary(ctx context.Context, matchID pgtype.UUID) (Match, error) {
	row := q.db.QueryRow(ctx, getMatchForSummary, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.Mode,
		&i.QuestionCount,
		&i.PerQuestionSeconds,
		&i.GlobalTimeoutSeconds,
		&i.SeedHash,
		&i.LeaderboardEligible,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const getPlayerStatesByMatch = `-- name: GetPlayerStatesByMatch :many
SELECT match_id, user_id, is_guest, joined_at, left_at, final_score, status, accuracy, streak_bonus_pct, answers
FROM player_match_state
WHERE match_id = $1
`

func (q *Queries) GetPlayerStatesByMatch(ctx context.Context, matchID pgtype.UUID) ([]PlayerMatchState, error) {
	rows, err := q.db.Query(ctx, getPlayerStatesByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerMatchState
	for rows.Next() {
		var i PlayerMatchState
		if err := rows.Scan(
			&i.MatchID,
			&i.UserID,
			&i.IsGuest,
			&i.JoinedAt,
			&i.LeftAt,
			&i.FinalScore,
			&i.Status,
			&i.Accuracy,
			&i.StreakBonusPct,
			&i.Answers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchStatus = `-- name: UpdateMatchStatus :exec
UPDATE matches
SET status = $1,
    started_at = COALESCE($2, started_at),
    completed_at = COALESCE($3, completed_at),
    updated_at = NOW()
WHERE match_id = $4
`

type UpdateMatchStatusParams struct {
	Status      string             `json:"status"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	MatchID     pgtype.UUID        `json:"match_id"`
}

func (q *Queries) UpdateMatchStatus(ctx context.Context, arg UpdateMatchStatusParams) error {
	_, err := q.db.Exec(ctx, updateMatchStatus,
		arg.Status,
		arg.StartedAt,
		arg.CompletedAt,
		arg.MatchID,
	)
	return err
}

const updatePlayerMatchResult = `-- name: UpdatePlayerMatchResult :exec
UPDATE player_match_state
SET final_score = $1,
    status = $2,
    accuracy = $3,
    streak_bonus_pct = $4,
    left_at = COALESCE($5, left_at),
    answers = COALESCE($6, answers),
    updated_at = NOW()
WHERE match_id = $7
  AND user_id = $8
`

type UpdatePlayerMatchResultParams struct {
	FinalScore     pgtype.Int4        `json:"final_score"`
	Status         string             `json:"status"`
	Accuracy       pgtype.Numeric     `json:"accuracy"`
	StreakBonusPct pgtype.Numeric     `json:"streak_bonus_pct"`
	LeftAt         pgtype.Timestamptz `json:"left_at"`
	Answers        []byte             `json:"answers"`
	MatchID        pgtype.UUID        `json:"match_id"`
	UserID         pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdatePlayerMatchResult(ctx context.Context, arg UpdatePlayerMatchResultParams) error {
	_, err := q.db.Exec(ctx, updatePlayerMatchResult,
		arg.FinalScore,
		arg.Status,
		arg.Accuracy,
		arg.StreakBonusPct,
		arg.LeftAt,
		arg.Answers,
		arg.MatchID,
		arg.UserID,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: audit.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertAuditLog = `-- name: InsertAuditLog :exec
INSERT INTO audit_logs (
    actor_id,
    entity_type,
    entity_id,
    action,
    payload
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type InsertAuditLogParams struct {
	ActorID    pgtype.UUID `json:"actor_id"`
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Action     string      `json:"action"`
	Payload    []byte      `json:"payload"`
}

func (q *Queries) InsertAuditLog(ctx context.Context, arg InsertAuditLogParams) error {
	_, err := q.db.Exec(ctx, insertAuditLog,
		arg.ActorID,
		arg.EntityType,
		arg.EntityID,
		arg.Action,
		arg.Payload,
	)
	return err
}

const listAuditLogsForEntity = `-- name: ListAuditLogsForEntity :many
SELECT audit_id, actor_id, entity_type, entity_id, action, payload, created_at, trace_id
FROM audit_logs
WHERE entity_type = $1
  AND entity_id = $2
ORDER BY created_at DESC
LIMIT $3
`

type ListAuditLogsForEntityParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Limit      int32       `json:"limit"`
}

func (q *Queries) ListAuditLogsForEntity(ctx context.Context, arg ListAuditLogsForEntityParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsForEntity, arg.EntityType, arg.EntityID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.AuditID,
			&i.ActorID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Payload,
			&i.CreatedAt,
			&i.TraceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
